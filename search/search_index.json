{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Typed Monads Monads have a reputation for being difficult to understand, but in this module we provide a simple Python implementation of different monadic tools. This will hopefully give some insight into what monads are all about. Installation $ pip install typed-monads Building form source $ git clone git@github.com:sammyrulez/typed-monads.git $ cd typed-monads $ python setup.py test $ python setup.py install Contributing If you find somthing odd open a bug type issue. Even better if you submit also a PR! Also feature request are welome! Project layout Disclaimer This is a fork of the original work by Correl Roush I added some utility methods to make it easier to use in my day to day code and better interate with the pythonic style ( ie List Comprehension ) Some of the functional programming terms descriptions are taken from Wikipedia.","title":"Home"},{"location":"#welcome-to-typed-monads","text":"Monads have a reputation for being difficult to understand, but in this module we provide a simple Python implementation of different monadic tools. This will hopefully give some insight into what monads are all about.","title":"Welcome to Typed Monads"},{"location":"#installation","text":"$ pip install typed-monads","title":"Installation"},{"location":"#building-form-source","text":"$ git clone git@github.com:sammyrulez/typed-monads.git $ cd typed-monads $ python setup.py test $ python setup.py install","title":"Building form source"},{"location":"#contributing","text":"If you find somthing odd open a bug type issue. Even better if you submit also a PR! Also feature request are welome!","title":"Contributing"},{"location":"#project-layout","text":"","title":"Project layout"},{"location":"#disclaimer","text":"This is a fork of the original work by Correl Roush I added some utility methods to make it easier to use in my day to day code and better interate with the pythonic style ( ie List Comprehension ) Some of the functional programming terms descriptions are taken from Wikipedia.","title":"Disclaimer"},{"location":"applicative/","text":"Applicative functors, or an applicative for short, allow for functorial computations to be sequenced (unlike plain functors), but don't allow using results from prior computations in the definition of subsequent ones (unlike monads). Applicative functors are the programming equivalent of lax monoidal functors with tensorial strength in category theory. Extends Functor . pure Wraps a value in an applicative functor. e.g.: Maybe.pure(\"abc\") == Just(\"abc\") Result.pure(123) == Ok(123) apply ( & ) Transforms the value contained in the instance's functor with a function wrapped in the same type of functor. The & operator implements apply on applicatives, and is right-associative. e.g.: increment = lambda x: x + 1 Just(3).apply(Just(increment)) == Just(increment) & Just(3) == Just(4) This can be very handily combined with map to apply curried functions to multiple arguments: subtract = lambda x: lambda y: x - y subtract * Just(10) & Just(4) == Just(6)","title":"Applicative"},{"location":"applicative/#pure","text":"Wraps a value in an applicative functor. e.g.: Maybe.pure(\"abc\") == Just(\"abc\") Result.pure(123) == Ok(123)","title":"pure"},{"location":"applicative/#apply","text":"Transforms the value contained in the instance's functor with a function wrapped in the same type of functor. The & operator implements apply on applicatives, and is right-associative. e.g.: increment = lambda x: x + 1 Just(3).apply(Just(increment)) == Just(increment) & Just(3) == Just(4) This can be very handily combined with map to apply curried functions to multiple arguments: subtract = lambda x: lambda y: x - y subtract * Just(10) & Just(4) == Just(6)","title":"apply (&amp;)"},{"location":"curring/","text":"Curring is not a monad: it is the technique of converting a function that takes multiple arguments into a sequence of functions that each take a single argument. It was introduced by Gottlob Frege developed by Moses Sch\u00f6nfinkel, and further developed by Haskell Curry . Mixing Higher order functions ( functions that return a function ) with moand is a very common programming style other functional programming languages. This is why curry decorator is included in this module. With curry decorator you can transform a function in a curried function: just pass some positional parameters and get back a function with the remaining ones. @curry def power(exp: int, base: int ) -> int: return math.pow(base, exp) square_fn = power(2) # a function that returns the square of the parameter","title":"Curring"},{"location":"functor/","text":"In mathematics, specifically category theory, a functor is a mapping between categories. In python is an object tha can be mapped to something else. map ( * ) Applies a function to the contents of a functor, transforming it from one thing to another. The * operator implements map on functors def wordcount(s: str): return len(s.split()) f.map(wordcount) == f * wordcount","title":"Functor"},{"location":"functor/#map","text":"Applies a function to the contents of a functor, transforming it from one thing to another. The * operator implements map on functors def wordcount(s: str): return len(s.split()) f.map(wordcount) == f * wordcount","title":"map (*)"},{"location":"future/","text":"Represents an asynchronous action. # Lazy values and operations mapped_future: Future[int] = Future.pure(1).map(lambda x: x + 1) await mapped_future # convert sync calls in async f: Callable[[int], int] = lambda x: x + 1 await Future.pure(3).map(f) == await Future.pure(3).apply(Future.pure(f)) Also implements Awaitable .","title":"Future"},{"location":"list/","text":"Represents a ordered sequence of items. Also implements Monoid . m_list: List[int] = List([1, 2, 4, 9]) for i in m_list: ... #Or filter with a generator evens: List[int] = [k for k in m_list if k % 2 == 0 ] # And use it like a monad doubles: List[int] = m_list.map(lambda i : i * 2) # Mixing and matching oop and fn m_list.fold(lambda k, h: k + h, 0) == 16 Flatten If you have a list of lists, and want to create one list (sequence) from them, use the flatten method to convert a list of lists into a single list m_list: List[Union[int, List[int]]] = List([1, 2, List([3, 4])]) len(m_list.flatten()) == 4","title":"List"},{"location":"list/#flatten","text":"If you have a list of lists, and want to create one list (sequence) from them, use the flatten method to convert a list of lists into a single list m_list: List[Union[int, List[int]]] = List([1, 2, List([3, 4])]) len(m_list.flatten()) == 4","title":"Flatten"},{"location":"maybe/","text":"Undefined values or operations are one particular problem that robust software should prepare for and handle gracefully. A Maybe instance of a certain type T will either be a Just object wrapping a value of that type, or Nothing . Mapping a function over Nothing will return Nothing without calling the function. Binding an operation with a Nothing will return Nothing without attempting the operation. Default value with or_else Is always nice to have a backup option: m_empty: Maybe[str] = Nothing() m_empty.or_else(\"backup\") == \"backup\" Differences with Optional The main difference Maybe and Optional is that you can chain operations without if guards statelments. There is a lot of interoperability between the two types if you want to limit the usage of Typed Monads to your code only. Just(2) == Maybe.fromOptional(2) Nothing() == Maybe.fromOptional(None) 2 == Just(2).toOptional() None == Nothing().toOptional()","title":"Maybe"},{"location":"maybe/#default-value-with-or_else","text":"Is always nice to have a backup option: m_empty: Maybe[str] = Nothing() m_empty.or_else(\"backup\") == \"backup\"","title":"Default value with or_else"},{"location":"maybe/#differences-with-optional","text":"The main difference Maybe and Optional is that you can chain operations without if guards statelments. There is a lot of interoperability between the two types if you want to limit the usage of Typed Monads to your code only. Just(2) == Maybe.fromOptional(2) Nothing() == Maybe.fromOptional(None) 2 == Just(2).toOptional() None == Nothing().toOptional()","title":"Differences with Optional"},{"location":"monad/","text":"A monad is an abstraction that allows structuring programs generically. Monads achieve this by providing their own data type (a particular type for each type of monad), which represents a specific form of computation, along with one procedure to wrap values of any basic type within the monad (yielding a monadic value) and another to compose functions that output monadic values (called monadic functions). This allows monads to simplify a wide range of problems, like handling potential undefined values (with the Maybe monad), or keeping values within a flexible, well-formed list (using the List monad). With a monad, a programmer can turn a complicated sequence of functions into a succinct pipeline that abstracts away auxiliary data management, control flow, or side-effects. Extends Applicative . bind ( >> ) Passes the value within the monad through an operation returning the same type of monad, allowing multiple operations to be chained. The >> operator implements bind on monads, and is left-associative. @curry def lookup(key: str, dictionary: Dict[str, str]) -> Maybe[str]: try: return Just(dictionary[key]) except KeyError: return Nothing() result = Just({\"hello\": \"world\"}).bind(lookup(\"hello\")).bind(lambda s: s.upper()) result = ( Just({\"hello\": \"world\"}) >> lookup(\"hello\") >> (lambda s: s.upper()) )","title":"What's a monad?"},{"location":"monad/#bind","text":"Passes the value within the monad through an operation returning the same type of monad, allowing multiple operations to be chained. The >> operator implements bind on monads, and is left-associative. @curry def lookup(key: str, dictionary: Dict[str, str]) -> Maybe[str]: try: return Just(dictionary[key]) except KeyError: return Nothing() result = Just({\"hello\": \"world\"}).bind(lookup(\"hello\")).bind(lambda s: s.upper()) result = ( Just({\"hello\": \"world\"}) >> lookup(\"hello\") >> (lambda s: s.upper()) )","title":"bind (&gt;&gt;)"},{"location":"monoid/","text":"In abstract algebra, a monoid is a set equipped with an associative binary operation and an identity element. Monoids are semigroups with identity. Such algebraic structures occur in several branches of mathematics. For example, the functions from a set into itself form a monoid with respect to function composition. Many abstract data types can be endowed with a monoid structure. In a common pattern, a sequence of elements of a monoid is \"folded\" or \"accumulated\" to produce a final value. mappend ( + ) Describes an associative binary operation for a type. mzero Provides an identity value for the mappend operation. mconcat Accumulates a list of values using mappend . Returns the mzero value if the list is empty.","title":"Monoid"},{"location":"monoid/#mappend","text":"Describes an associative binary operation for a type.","title":"mappend (+)"},{"location":"monoid/#mzero","text":"Provides an identity value for the mappend operation.","title":"mzero"},{"location":"monoid/#mconcat","text":"Accumulates a list of values using mappend . Returns the mzero value if the list is empty.","title":"mconcat"},{"location":"mypy/","text":"WIP","title":"MyPy support"},{"location":"result/","text":"Represents a state of success or failure, declaring a type for each. It is the monadic way to error handling. A Result instance will either be an Ok object wrapping a value of the success type T , or an Err object wrapping a value of the failure type E . Mapping a function over an Err will return the Err unchanged without calling the function. Binding an operation with an Err will return the Err unchanged without attempting the operation. m: Result[int, str] = Ok(5) increment: Callable[[int],int] = lambda x : x +1 Ok(6) == m.map(increment) e: Result[int, str] = Err(\"oops\") Err(\"oops\") == e.map(increment) # still an error","title":"Result"}]}